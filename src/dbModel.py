from datetime import *

from peewee import *
from constants import *
from datetime import date
from replies import *

# DB
db = SqliteDatabase('./events.db', pragmas={
    'journal_mode': 'wal',
    'cache_size': -1024 * 64})


# DB tables
class Events(Model):
    id = AutoField(unique=True, null=False)
    name = CharField()
    owner = CharField()
    start_dt = DateField(formats=[dateFormat])
    start_time = TimeField(formats=[timeFormat])
    duration = CharField()
    description = CharField()
    event_status = IntegerField(default=None)

    class Meta:
        db_table = 'events'
        database = db


class Users(Model):
    id = PrimaryKeyField(unique=True, null=False)
    name = CharField(default="")
    userType = IntegerField(-1)
    userName = CharField(default="")
    status = IntegerField(default=UserStatus.UNKNOWN)

    class Meta:
        db_table = 'users'
        database = db


class Registrations(Model):
    id = AutoField(unique=True, null=False)
    eventId = ForeignKeyField(Events, backref='events')
    userId = ForeignKeyField(Users, backref='users')
    active = IntegerField()

    class Meta:
        db_table = 'registrations'
        database = db


# DB functions
def add_event(name="", owner="", start_dt="", start_time="",
              duration="", description="", event_status=EventStatus.UNKNOWN):
    Events.create(
        name=name,
        owner=owner,
        start_dt=start_dt,
        start_time=start_time,
        duration=duration,
        description=description,
        event_status=event_status
    )

    return True


def add_user(id, name="", userType=UserType.UNKNOWN, userName="", status=UserStatus.UNKNOWN):
    Users.create(
        id=id,
        name=name,
        userType=userType,
        userName=userName,
        status=status
    )

    return True


def add_registration(eventId=0, userId=0, active=RegistrationStatus.INACTIVE):
    app = Registrations.create(
        eventId=eventId,
        userId=userId,
        active=active
    )
    app.save()
    return True


def get_table(Class):
    app_table = (Class.select())
    return app_table


def registered(id):
    users = get_table(Users)

    for line in users:
        if line.id == id:
            return True

    return False


def checkAdminStatus(id):
    users = get_table(Users)

    for line in users:
        if line.id == id and line.userType == UserType.ADMIN:
            return True

    return False


def getEvent(id):
    new_table = Events.select().where(Events.id == id).execute()

    return new_table


def deleteEvent(id):
    Events.delete().where(Events.id == id).execute()
    return 0


def giveAdminStatus(id, password=""):
    if password == magicWord:
        query = Users.update(userType=UserType.ADMIN).where((Users.id == id))
        query.execute()
        return True
    else:
        return False


def giveGuestStatus(id):
    query = Users.update(userType=UserType.GUEST).where((Users.id == id))
    query.execute()


def fillUserFIO(id, FIO):
    users_table = get_table(Users)
    for user in users_table:
        if user.id == id:
            user.name = FIO
            user.status = UserStatus.REGISTRATED
            user.save()
            return 0
    return -1


def getUserType(id) -> int:
    query = Users.get_by_id(id)
    return query.userType


def getUserName(id) -> str:
    query = Users.get_by_id(id)
    return query.name


def getTodayEvents() -> str:
    today = date.today().strftime(dateFormat)
    return selectValidEventForTheDay(today)


# –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–≤–µ–Ω—Ç—ã —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–∏
def getWeekEvents() -> [str]:
    dates = getThisWeekDates()

    events = [None for i in range(0, 7)]
    for i in range(0, 7):
        events[i] = selectValidEventForTheDay(dates[i])
        if events[i] is None or events[i] == "":
            events[i] = reply_nothing_found

    return events


# true on success
def addRegistrationOnEvent(event_id, user_id) -> bool:
    try:
        Registrations.get(Registrations.eventId == event_id,
                          Registrations.userId == user_id,
                          Registrations.active == RegistrationStatus.ACTIVE)
    except:
        add_registration(event_id, user_id, RegistrationStatus.ACTIVE)
        return True

    return False


# true on success
def calncelRegistrationOnEvent(event_id, user_id) -> bool:
    try:
        print(event_id, user_id)
        Registrations.get(Registrations.eventId == event_id,
                          Registrations.userId == user_id,
                          Registrations.active == RegistrationStatus.ACTIVE)

        Registrations.update(active=RegistrationStatus.INACTIVE) \
            .where(Registrations.eventId == event_id,
                   Registrations.userId == user_id,
                   Registrations.active == RegistrationStatus.ACTIVE).execute()
        return True
    except Exception as e:
        print(str(e))
        return False


# –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç a–∫—Ç–∏–≤–Ω—ã–µ –∏–≤–µ–Ω—Ç—ã –Ω–∞ –Ω–µ–¥–µ–ª—é –≤–ø–µ—Ä–µ–¥ –Ω–µ –±–æ–ª–µ–µ %maxAmount
def getActiveWeekUpfrontEvents(maxAmount) -> [dict]:
    dates = getWeekUpfrontDates()
    eventNames = []
    for date in dates:
        eventNames.append(selectEventNamesForTheDay(date))
        if len(eventNames) >= maxAmount:
            eventNames = eventNames[0:maxAmount]
            break

    eventNames = [item for sublist in eventNames for item in sublist]
    return eventNames


# –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∏–≤–µ–Ω—Ç—ã –Ω–∞ –Ω–µ–¥–µ–ª—é –≤–ø–µ—Ä–µ–¥ –Ω–µ –±–æ–ª–µ–µ %maxAmount
def getAllWeekUpfrontEvents(maxAmount) -> [dict]:
    dates = getWeekUpfrontDates()
    eventNames = []
    for date in dates:
        eventNames.append(selectEventNamesForTheDay(date, status=EventStatus.UNKNOWN))
        if len(eventNames) >= maxAmount:
            eventNames = eventNames[0:maxAmount]
            break

    eventNames = [item for sublist in eventNames for item in sublist]
    return eventNames


def getRegistratedStatsForGivenMonth(month):
    today = date.today()
    firstDay = datetime(today.year, int(month), 1)
    lastDay = firstDay + timedelta(weeks=4) - timedelta(days=1)

    firstDay = firstDay.strftime(dateFormat)
    lastDay = lastDay.strftime(dateFormat)

    print("1 ", firstDay, "2 ", lastDay)
    events = selectStatsForGivenMonth(firstDay, lastDay)
    return events


def selectValidEventForTheDay(day):
    todayEvents = Events.select().where(Events.start_dt == day, Events.event_status == EventStatus.GOINGTO).execute()
    events = []
    for line in todayEvents:
        events.append(reply_event_markup.format(line.name, line.start_dt,
                                                line.start_time, line.duration, line.owner, line.description))
    return '\n'.join(events)


def selectEventNamesForTheDay(day, status=EventStatus.GOINGTO):
    if status != EventStatus.UNKNOWN:
        todayEvents = Events.select().where(Events.start_dt == day, Events.event_status == status).execute()
    else:
        todayEvents = Events.select().where(Events.start_dt == day).execute()
    events = []
    for line in todayEvents:
        event = {"id": line.id,
                 "name": line.name,
                 "start_dt": line.start_dt,
                 "status": line.event_status,
                 "owner": line.owner,
                 "description": line.description,
                 "start_time": str(line.start_time)}
        events.append(event)

    return events


def selectStatsForGivenMonth(firstDay, lastDay) -> [dict]:
    query = (Registrations
             .select(Events.id,
                     Events.name,
                     fn.Sum(Case(None, ((Registrations.active == RegistrationStatus.ACTIVE, 1),), 0)).alias(
                         'count_active'),
                     fn.Sum(Case(None, ((Registrations.active == RegistrationStatus.INACTIVE, 1),), 0)).alias(
                         'count_inactive'))
             .join(Events)
             .group_by(Events.id, Events.name)
             .where(Events.start_dt >= firstDay, Events.start_dt <= lastDay))

    agg = []
    for line in query:
        agg.append({"id": line.eventId.id, "name": line.eventId.name,
                    "count_active": line.count_active, "count_inactive": line.count_inactive})

    return agg


# –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ –∞–π–¥–∏—à–Ω–∏–∫—É –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–µ–≥–∏ –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ–∑–∂–µ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–π –¥–∞—Ç—ã
def getUserActiveRegistratedEvents(id, maxAmount) -> [dict]:
    eventNames = selectUserActiveRegistratedEvents(id)
    if len(eventNames) >= maxAmount:
        eventNames = eventNames[0:maxAmount]

    return eventNames


def selectUserActiveRegistratedEvents(id):
    today = date.today()
    query = (Registrations
             .select(Registrations.id, Events.name, Events.id, Registrations.eventId)
             .join(Events)
             .where(Registrations.userId == id,
                    Events.start_dt.year >= today.year,
                    Events.start_dt.month >= today.month,
                    Events.start_dt.day >= today.day,
                    Registrations.active == RegistrationStatus.ACTIVE))

    events = []
    for line in query:
        event = {"id": line.id,
                 "name": line.eventId.name,
                 "eventId": line.eventId.id
                 }
        # print("line", event)
        events.append(event)

    return events


def changeRegistrationStatus():
    query = Registrations.update(id=id).where((Users.id == id))
    query.execute()


def loadSomeEvents():
    add_event("üï∫ dick—Å–∫–æ—Ç–µ–∫–∞", "@daniil_toro", "08-09-2021", "10:00", "4 —á–∞—Å–∞",
              "–û—á –∫—Ä—É—Ç–∞—è –¥–∏—Å–∫–æ—Ç–µ–∫–∞ —Å —Ç—É—Å–∏—á–µ–º –∏ –ø–∏–≤–æ–º", EventStatus.GOINGTO)
    add_event("‚òï –ß–∞–µ–ø–∏—Ç–∏–µ", "@daniil_toro", "25-09-2021", "21:00", "10 —á–∞—Å–æ–≤",
              "–ü—å–µ–º —á–∞–π —Å —à–∏—à–∫–∞–º–∏", EventStatus.GOINGTO)
    add_event("‚òï –û—Ç–º–µ–Ω–µ–Ω–Ω–æ–µ –ß–∞–µ–ø–∏—Ç–∏–µ", "@utyuzhnikova", "18-09-2021", "21:00", "10 —á–∞—Å–æ–≤",
              "–ü—å–µ–º —á–∞–π —Å —à–∏—à–∫–∞–º–∏", EventStatus.CANCELED)
    add_event("üç∫ –ü–∏–≤–æ–ø–∏–ª—å–Ω—è", "@daniil_toro", "27-09-2021", "21:00", "–≤—Å—é –Ω–æ—á—å –µ–∫–ª–º–Ω",
              "–ë—É–¥–µ–º –ø–∏—Ç—å –ø–∏–≤–æ –≤—Å—é –Ω–æ—á—å –∏ –∫—É—à–∞—Ç—å –∂–∞—Ä–µ–Ω—ã–µ –ø–µ–ª—å–º–µ–Ω–∏", EventStatus.GOINGTO)
    add_event("üíò –ë–ª–∞–π–Ω–¥-–¥–µ–π—Ç–∏–Ω–≥!", "@utyuzhnikova", "25-09-2021", "21:00", "20 –º–∏–Ω—É—Ç–æ–∫",
              "–í—Å–µ–º –∑–∞–≤—è–∂—É—Ç –≥–ª–∞–∑–∞ –∏ –∑–∞—Å—Ç–∞–≤—è—Ç –≤—Å—Ç—Ä–µ—á–∞—Ç—å—Å—è –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º", EventStatus.GOINGTO)
    add_event("ü•û –ú–∞—Å–ª–µ–Ω–∏—Ü–∞", "@kattyog", "23-09-2021", "00:00", "–Ω–µ–¥–µ–ª—é!!",
              "–ë–ª–∏–Ω—ã –∫—É—à–∞–µ–º –Ω–∏–∫–æ–≥–æ –Ω–µ —Å–ª—É—à–∞–µ–º", EventStatus.GOINGTO)
    add_event("üìö –ö–Ω–∏–∂–Ω—ã–π –≤–µ—á–µ—Ä", "@utyuzhnikova", "22-09-2021", "12:00", "6 —á–∞—Å–æ–≤",
              "–ß–∏—Ç–∞–µ–º –∫–Ω–∏–∂–∫–∏ 6 —á–∞—Å–æ–≤ –ø–æ–¥—Ä—è–¥", EventStatus.CANCELED)
    add_event("üëñ –°–≤–æ–ø-–ø–∞—Ä—Ç–∏", "@daniil_toro", "22-10-2021", "09:00", "all day long",
              "–°–≤–æ–ø–∞–µ–º—Å—è —Å–≤–æ–ø–∞–º–∏ —Ö–µ-—Ö–µ", EventStatus.GOINGTO)
    add_event("üë®‚Äçüíº –ë–∏–∑–Ω–µ—Å-—Ç—Ä–µ–Ω–∏–Ω–≥", "@daniil_toro", "26-10-2021", "09:00", "all day long",
              "–ë–∏–∑–Ω–µ—Å —Ç—Ä–µ–Ω–µ—Ä—É–µ–º—Å—è —Ö–µ-—Ö–µ", EventStatus.GOINGTO)


def getThisWeekDates():
    today = date(date.today().year, date.today().month, date.today().day)
    dates = [today + timedelta(days=i) for i in range(0 - today.weekday(), 7 - today.weekday())]
    dates = [i.strftime(dateFormat) for i in dates]

    return dates


def getWeekUpfrontDates():
    today = date(date.today().year, date.today().month, date.today().day)
    dates = [today + timedelta(days=i) for i in range(0, 7)]
    dates = [i.strftime(dateFormat) for i in dates]

    return dates


def selectAllFromUsers() -> [dict]:
    users_table = get_table(Users)
    users = []
    for line in users_table:
        users.append({"id": line.id, "name": line.name, "userType": line.userType, "status": line.status})

    return users


def selectAllFromRegs() -> [dict]:
    reg_table = get_table(Registrations)
    reg = []
    for line in reg_table:
        reg.append({"id": line.id, "eventId": line.eventId, "userId": line.userId, "active": line.active})

    return reg


def updateEvent(event):
    try:
        query = Events.update(name=event["name"], start_dt=event["start_dt"], start_time=event["start_time"],
                              owner=event["owner"], event_status=event["status"], description=event["description"]) \
            .where((Events.id == event["id"]))
        query.execute()

        return True
    except Exception as e:
        print(str(e))

    return False


if __name__ == "__main__":
    # db and tables init
    try:
        db.connect()
        Users.create_table()
        Events.create_table()
        Registrations.create_table()
    except InternalError as px:
        print(str(px))

    loadSomeEvents()
